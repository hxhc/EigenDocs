<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.4.90 (git rev 21cd3fe20990a5ac1d683806f605110962aac3f1)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classEigen_1_1VectorwiseOp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="classEigen_1_1VectorwiseOp-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle"><div class="title">Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__DenseMatrixManipulation__chapter.html">Dense matrix and array manipulation</a> &raquo; <a class="el" href="group__DenseMatrixManipulation__Reference.html">Reference</a> &raquo; <a class="el" href="group__Core__Module.html">Core module</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ExpressionType, int Direction&gt;<br />
class Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt;</div><p>Pseudo expression providing broadcasting and partial reduction operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>the type of the object on which to do partial reductions </td></tr>
    <tr><td class="paramname">Direction</td><td>indicates whether to operate on columns (<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a>) or rows (<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7a961c62410157b64033839488f4d7f7e4">Horizontal</a>)</td></tr>
  </table>
  </dd>
</dl>
<p>This class represents a pseudo expression with broadcasting and partial reduction features. It is the return type of <a class="el" href="classEigen_1_1DenseBase.html#a58837c81de446efbdb58da07b73a63c1">DenseBase::colwise()</a> and <a class="el" href="classEigen_1_1DenseBase.html#aa1cabd3404528fe8cec4bab43d74bffc">DenseBase::rowwise()</a> and most of the time this is the only way it is explicitly used.</p>
<p>To understand the logic of rowwise/colwise expression, let's consider a generic case <code>A.colwise().foo()</code> where <code>foo</code> is any method of <code><a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a></code>. This expression is equivalent to applying <code>foo()</code> to each column of <code>A</code> and then re-assemble the outputs in a matrix expression: </p><div class="fragment"><div class="line">[A.col(0).foo(), A.col(1).foo(), ..., A.col(A.cols()-1).foo()] </div>
</div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().sum() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum absolute value of each column:&quot;</span></div>
<div class="line">     &lt;&lt; endl &lt;&lt; m.cwiseAbs().colwise().maxCoeff() &lt;&lt; endl;</div>
<div class="ttc" id="aclassEigen_1_1Matrix_html"><div class="ttname"><a href="classEigen_1_1Matrix.html">Eigen::Matrix</a></div><div class="ttdoc">The matrix class, also used for vectors and row-vectors.</div><div class="ttdef"><b>Definition</b> Matrix.h:182</div></div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>The <a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a> and <a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a> methods are obviously exceptions to the previous rule as they return STL-compatible begin/end iterators to the rows or columns of the nested expression. Typical use cases include for-range-loop and calls to STL algorithms:</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3i</a> m = Matrix3i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the initial matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line"><span class="keywordtype">int</span> i = -1;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> c: m.colwise()) {</div>
<div class="line">  c *= i;</div>
<div class="line">  ++i;</div>
<div class="line">}</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m after the for-range-loop:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line"><span class="keyword">auto</span> cols = m.colwise();</div>
<div class="line"><span class="keyword">auto</span> it = std::find_if(cols.cbegin(), cols.cend(),</div>
<div class="line">                       [](Matrix3i::ConstColXpr x) { return x.squaredNorm() == 0; });</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;The first empty column is: &quot;</span> &lt;&lt; distance(cols.cbegin(),it) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><p>For a partial reduction on an empty input, some rules apply. For the sake of clarity, let's consider a vertical reduction:</p><ul>
<li>If the number of columns is zero, then a 1x0 row-major vector expression is returned.</li>
<li>Otherwise, if the number of rows is zero, then<ul>
<li>a row vector of zeros is returned for sum-like reductions (sum, squaredNorm, norm, etc.)</li>
<li>a row vector of ones is returned for a product reduction (e.g., <code><a class="el" href="group__matrixtypedefs.html#ga99b41a69f0bf64eadb63a97f357ab412" title="Dynamic×Dynamic matrix of type double.">MatrixXd(n,0)</a>.colwise().<a class="el" href="classEigen_1_1VectorwiseOp.html#a01bcd17504f30b55b4910ddb75598f79">prod()</a></code>)</li>
<li>an assert is triggered for all other reductions (minCoeff,maxCoeff,redux(bin_op))</li>
</ul>
</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a58837c81de446efbdb58da07b73a63c1">DenseBase::colwise()</a>, <a class="el" href="classEigen_1_1DenseBase.html#aa1cabd3404528fe8cec4bab43d74bffc">DenseBase::rowwise()</a>, class <a class="el" href="classEigen_1_1PartialReduxExpr.html" title="Generic expression of a partially reduxed matrix.">PartialReduxExpr</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4907c654e5810edd98e4162093b19532"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a></td></tr>
<tr class="separator:a4907c654e5810edd98e4162093b19532"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9c2b4740bf190492bf231d8e244b25c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AllReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9c2b4740bf190492bf231d8e244b25c1">all</a> () const</td></tr>
<tr class="separator:a9c2b4740bf190492bf231d8e244b25c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96210c9f83bd375f8ce862bd62ab70e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AnyReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a96210c9f83bd375f8ce862bd62ab70e6">any</a> () const</td></tr>
<tr class="separator:a96210c9f83bd375f8ce862bd62ab70e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf3325f535ac011ed61f14ed4330618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin</a> ()</td></tr>
<tr class="separator:abbf3325f535ac011ed61f14ed4330618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf91f2a57a26e88e7131fcd9c194f93f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aaf91f2a57a26e88e7131fcd9c194f93f">begin</a> () const</td></tr>
<tr class="separator:aaf91f2a57a26e88e7131fcd9c194f93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2fbc5296470a94379cbcb33bb9c24d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">BlueNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4d2fbc5296470a94379cbcb33bb9c24d">blueNorm</a> () const</td></tr>
<tr class="separator:a4d2fbc5296470a94379cbcb33bb9c24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b237a2b46479de5c905d2bcc54f34c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7b237a2b46479de5c905d2bcc54f34c4">cbegin</a> () const</td></tr>
<tr class="separator:a7b237a2b46479de5c905d2bcc54f34c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57859b88a32b8b393a427c4cab3581a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a57859b88a32b8b393a427c4cab3581a7">cend</a> () const</td></tr>
<tr class="separator:a57859b88a32b8b393a427c4cab3581a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6b797457895f11a7682b3a16f263bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">CountReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a5c6b797457895f11a7682b3a16f263bb">count</a> () const</td></tr>
<tr class="separator:a5c6b797457895f11a7682b3a16f263bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec95725eed4adb5ccf65fbb6e907d12e"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aec95725eed4adb5ccf65fbb6e907d12e">crbegin</a> () const</td></tr>
<tr class="separator:aec95725eed4adb5ccf65fbb6e907d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fa202916349d11e476f459543395ef"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a23fa202916349d11e476f459543395ef">crend</a> () const</td></tr>
<tr class="separator:a23fa202916349d11e476f459543395ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe1a2a012ce0ab0e8da6af134073039"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ga2fe1a2a012ce0ab0e8da6af134073039"><td class="memTemplItemLeft" align="right" valign="top">const CrossReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga2fe1a2a012ce0ab0e8da6af134073039">cross</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ga2fe1a2a012ce0ab0e8da6af134073039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d189042b8322e40772d41c63b9d3bb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end</a> ()</td></tr>
<tr class="separator:a9d189042b8322e40772d41c63b9d3bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0dcb34bb4903ffa1ab3634188ecff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ad3b0dcb34bb4903ffa1ab3634188ecff">end</a> () const</td></tr>
<tr class="separator:ad3b0dcb34bb4903ffa1ab3634188ecff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f220045efa302626c287088b63b6ba9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">HNormalizedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga1f220045efa302626c287088b63b6ba9">hnormalized</a> () const</td></tr>
<tr class="memdesc:ga1f220045efa302626c287088b63b6ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">column or row-wise homogeneous normalization  <br /></td></tr>
<tr class="separator:ga1f220045efa302626c287088b63b6ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf99305a3d7432318236df7b80022df37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Homogeneous.html">HomogeneousReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#gaf99305a3d7432318236df7b80022df37">homogeneous</a> () const</td></tr>
<tr class="separator:gaf99305a3d7432318236df7b80022df37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c44e033eec33586ae8093a6366da75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">HypotNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a00c44e033eec33586ae8093a6366da75">hypotNorm</a> () const</td></tr>
<tr class="separator:a00c44e033eec33586ae8093a6366da75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4f61d09bf8f83cad382dfb037aee9c"><td class="memTemplParams" colspan="2">template&lt;int p&gt; </td></tr>
<tr class="memitem:ade4f61d09bf8f83cad382dfb037aee9c"><td class="memTemplItemLeft" align="right" valign="top">const LpNormReturnType&lt; p &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ade4f61d09bf8f83cad382dfb037aee9c">lpNorm</a> () const</td></tr>
<tr class="separator:ade4f61d09bf8f83cad382dfb037aee9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6646b584db116c1661b5bb56750bd6f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MaxCoeffReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a6646b584db116c1661b5bb56750bd6f6">maxCoeff</a> () const</td></tr>
<tr class="separator:a6646b584db116c1661b5bb56750bd6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7d867f9e6b74a1bc7f108d646cfa85"><td class="memItemLeft" align="right" valign="top">const MeanReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aaf7d867f9e6b74a1bc7f108d646cfa85">mean</a> () const</td></tr>
<tr class="separator:aaf7d867f9e6b74a1bc7f108d646cfa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7b8c03d180b126fde0ac212e2b0b76"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MinCoeffReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7d7b8c03d180b126fde0ac212e2b0b76">minCoeff</a> () const</td></tr>
<tr class="separator:a7d7b8c03d180b126fde0ac212e2b0b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af726d1dfd9a7a67b76e639db1a9f352e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">NormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#af726d1dfd9a7a67b76e639db1a9f352e">norm</a> () const</td></tr>
<tr class="separator:af726d1dfd9a7a67b76e639db1a9f352e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1084153780dc8d2c062fee97651a45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#adb1084153780dc8d2c062fee97651a45">normalize</a> ()</td></tr>
<tr class="separator:adb1084153780dc8d2c062fee97651a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe5af25f4d5c01d4eb844b13665219a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename OppositeExtendedType&lt; <a class="el" href="classEigen_1_1CwiseUnaryOp.html">NormReturnType</a> &gt;::Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4fe5af25f4d5c01d4eb844b13665219a">normalized</a> () const</td></tr>
<tr class="separator:a4fe5af25f4d5c01d4eb844b13665219a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e68903d3f06c993824f9f4ab9b2dfb"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a03e68903d3f06c993824f9f4ab9b2dfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a03e68903d3f06c993824f9f4ab9b2dfb">operator*</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a03e68903d3f06c993824f9f4ab9b2dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754261f465f54897e7fdcb8b8e168193"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a754261f465f54897e7fdcb8b8e168193"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a754261f465f54897e7fdcb8b8e168193">operator*=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a754261f465f54897e7fdcb8b8e168193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8cdb3bf914538158ec5e2d3f098289"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3e8cdb3bf914538158ec5e2d3f098289"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_sum_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a3e8cdb3bf914538158ec5e2d3f098289">operator+</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a3e8cdb3bf914538158ec5e2d3f098289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed7f1387a37976c0fa96727d8988cc4"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:abed7f1387a37976c0fa96727d8988cc4"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#abed7f1387a37976c0fa96727d8988cc4">operator+=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:abed7f1387a37976c0fa96727d8988cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3322dbbc17aaf778ce8e71412cedc8"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a1b3322dbbc17aaf778ce8e71412cedc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_difference_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a1b3322dbbc17aaf778ce8e71412cedc8">operator-</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a1b3322dbbc17aaf778ce8e71412cedc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da734a56ad8885d59536990669d9251"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3da734a56ad8885d59536990669d9251"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a3da734a56ad8885d59536990669d9251">operator-=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a3da734a56ad8885d59536990669d9251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96238a50bff53f4e2d2004e8cc10ec51"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a96238a50bff53f4e2d2004e8cc10ec51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a96238a50bff53f4e2d2004e8cc10ec51">operator/</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a96238a50bff53f4e2d2004e8cc10ec51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508f9152d709faadc120d615e3c33b68"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a508f9152d709faadc120d615e3c33b68"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a508f9152d709faadc120d615e3c33b68">operator/=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a508f9152d709faadc120d615e3c33b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89e67f222ca4059d9d1097c22cc7ff9"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ab89e67f222ca4059d9d1097c22cc7ff9"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ab89e67f222ca4059d9d1097c22cc7ff9">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:ab89e67f222ca4059d9d1097c22cc7ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bcd17504f30b55b4910ddb75598f79"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">ProdReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a01bcd17504f30b55b4910ddb75598f79">prod</a> () const</td></tr>
<tr class="separator:a01bcd17504f30b55b4910ddb75598f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a8087eb76e210b07192c81d362dd1e"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a91a8087eb76e210b07192c81d362dd1e">rbegin</a> ()</td></tr>
<tr class="separator:a91a8087eb76e210b07192c81d362dd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e8a0230fcc049346057ef1a6efe02"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aa73e8a0230fcc049346057ef1a6efe02">rbegin</a> () const</td></tr>
<tr class="separator:aa73e8a0230fcc049346057ef1a6efe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92284ced994812cd5e7f4520c0445fb"><td class="memTemplParams" colspan="2">template&lt;typename BinaryOp &gt; </td></tr>
<tr class="memitem:af92284ced994812cd5e7f4520c0445fb"><td class="memTemplItemLeft" align="right" valign="top">const ReduxReturnType&lt; BinaryOp &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#af92284ced994812cd5e7f4520c0445fb">redux</a> (const BinaryOp &amp;func=BinaryOp()) const</td></tr>
<tr class="separator:af92284ced994812cd5e7f4520c0445fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9592e93b704f7712e8f33631a2efe8f"><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aa9592e93b704f7712e8f33631a2efe8f">rend</a> ()</td></tr>
<tr class="separator:aa9592e93b704f7712e8f33631a2efe8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb3e3ceca37ae0a6e313f80743f767a"><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#afeb3e3ceca37ae0a6e313f80743f767a">rend</a> () const</td></tr>
<tr class="separator:afeb3e3ceca37ae0a6e313f80743f767a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0c8dc9e9c4aeaa2057f15800f5c18c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">ReplicateReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a5f0c8dc9e9c4aeaa2057f15800f5c18c">replicate</a> (<a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a> factor) const</td></tr>
<tr class="separator:a5f0c8dc9e9c4aeaa2057f15800f5c18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01aca6b0627570d35e3b3000acd10b88"><td class="memTemplParams" colspan="2">template&lt;int Factor&gt; </td></tr>
<tr class="memitem:a01aca6b0627570d35e3b3000acd10b88"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; ExpressionType, isVertical *Factor+isHorizontal, isHorizontal *Factor+isVertical &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a01aca6b0627570d35e3b3000acd10b88">replicate</a> (<a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a> factor=Factor) const</td></tr>
<tr class="separator:a01aca6b0627570d35e3b3000acd10b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8caf5367e2bd636536c8a0e0c89fe15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ab8caf5367e2bd636536c8a0e0c89fe15">reverse</a> ()</td></tr>
<tr class="separator:ab8caf5367e2bd636536c8a0e0c89fe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0428f561b5757e2c85e8d72022eec1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aeb0428f561b5757e2c85e8d72022eec1">reverse</a> () const</td></tr>
<tr class="separator:aeb0428f561b5757e2c85e8d72022eec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd7c273eb2ba8defaab2d55156936b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ab9dd7c273eb2ba8defaab2d55156936b">reverseInPlace</a> ()</td></tr>
<tr class="separator:ab9dd7c273eb2ba8defaab2d55156936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01474cf971473a73c919f6a99323d4f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SquaredNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a01474cf971473a73c919f6a99323d4f5">squaredNorm</a> () const</td></tr>
<tr class="separator:a01474cf971473a73c919f6a99323d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add48fd836be98ed280cac23518db0916"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">StableNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#add48fd836be98ed280cac23518db0916">stableNorm</a> () const</td></tr>
<tr class="separator:add48fd836be98ed280cac23518db0916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7030fc687c24d687ed7cd70733ba611c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SumReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7030fc687c24d687ed7cd70733ba611c">sum</a> () const</td></tr>
<tr class="separator:a7030fc687c24d687ed7cd70733ba611c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a595c33d2a82427a1159568b0b8438554"><td class="memItemLeft" align="right" valign="top">random_access_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a></td></tr>
<tr class="separator:a595c33d2a82427a1159568b0b8438554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb8aaf24528efcdac1782aacf99b8dd"><td class="memItemLeft" align="right" valign="top">random_access_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a></td></tr>
<tr class="separator:a9fb8aaf24528efcdac1782aacf99b8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4907c654e5810edd98e4162093b19532" name="a4907c654e5810edd98e4162093b19532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4907c654e5810edd98e4162093b19532">&#9670;&#160;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::Index</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>since <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c2b4740bf190492bf231d8e244b25c1" name="a9c2b4740bf190492bf231d8e244b25c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2b4740bf190492bf231d8e244b25c1">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AllReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing whether <b>all</b> coefficients of each respective column (or row) are <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ae42ab60296c120e9f45ce3b44e1761a4">DenseBase::all()</a> </dd></dl>

</div>
</div>
<a id="a96210c9f83bd375f8ce862bd62ab70e6" name="a96210c9f83bd375f8ce862bd62ab70e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96210c9f83bd375f8ce862bd62ab70e6">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AnyReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing whether <b>at</b> <b>least</b> one coefficient of each respective column (or row) is <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#abfbf4cb72dd577e62fbe035b1c53e695">DenseBase::any()</a> </dd></dl>

</div>
</div>
<a id="abbf3325f535ac011ed61f14ed4330618" name="abbf3325f535ac011ed61f14ed4330618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf3325f535ac011ed61f14ed4330618">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns an iterator to the first row (rowwise) or column (colwise) of the nested expression. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a7b237a2b46479de5c905d2bcc54f34c4">cbegin()</a> </dd></dl>

</div>
</div>
<a id="aaf91f2a57a26e88e7131fcd9c194f93f" name="aaf91f2a57a26e88e7131fcd9c194f93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf91f2a57a26e88e7131fcd9c194f93f">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a> </p>

</div>
</div>
<a id="a4d2fbc5296470a94379cbcb33bb9c24d" name="a4d2fbc5296470a94379cbcb33bb9c24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2fbc5296470a94379cbcb33bb9c24d">&#9670;&#160;</a></span>blueNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">BlueNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::blueNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, using Blue's algorithm. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::blueNorm() </dd></dl>

</div>
</div>
<a id="a7b237a2b46479de5c905d2bcc54f34c4" name="a7b237a2b46479de5c905d2bcc54f34c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b237a2b46479de5c905d2bcc54f34c4">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a> </p>

</div>
</div>
<a id="a57859b88a32b8b393a427c4cab3581a7" name="a57859b88a32b8b393a427c4cab3581a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57859b88a32b8b393a427c4cab3581a7">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a> </p>

</div>
</div>
<a id="a5c6b797457895f11a7682b3a16f263bb" name="a5c6b797457895f11a7682b3a16f263bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6b797457895f11a7682b3a16f263bb">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">CountReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing the number of <code>true</code> coefficients of each respective column (or row). This expression can be assigned to a vector whose entries have the same type as is used to index entries of the original matrix; for dense matrices, this is <code>std::ptrdiff_t</code> .</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix&lt;ptrdiff_t, 3, 1&gt;</a> res = (m.array() &gt;= 0.5).rowwise().count();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the count of elements larger or equal than 0.5 of each row:&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; res &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ab778f1c907d15d20fcc23f32ab102172">DenseBase::count()</a> </dd></dl>

</div>
</div>
<a id="aec95725eed4adb5ccf65fbb6e907d12e" name="aec95725eed4adb5ccf65fbb6e907d12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec95725eed4adb5ccf65fbb6e907d12e">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a91a8087eb76e210b07192c81d362dd1e">rbegin()</a> </p>

</div>
</div>
<a id="a23fa202916349d11e476f459543395ef" name="a23fa202916349d11e476f459543395ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fa202916349d11e476f459543395ef">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#aa9592e93b704f7712e8f33631a2efe8f">rend()</a> </p>

</div>
</div>
<a id="a9d189042b8322e40772d41c63b9d3bb5" name="a9d189042b8322e40772d41c63b9d3bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d189042b8322e40772d41c63b9d3bb5">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9fb8aaf24528efcdac1782aacf99b8dd">iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns an iterator to the row (resp. column) following the last row (resp. column) of the nested expression </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a57859b88a32b8b393a427c4cab3581a7">cend()</a> </dd></dl>

</div>
</div>
<a id="ad3b0dcb34bb4903ffa1ab3634188ecff" name="ad3b0dcb34bb4903ffa1ab3634188ecff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b0dcb34bb4903ffa1ab3634188ecff">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1VectorwiseOp.html#a595c33d2a82427a1159568b0b8438554">const_iterator</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a> </p>

</div>
</div>
<a id="a00c44e033eec33586ae8093a6366da75" name="a00c44e033eec33586ae8093a6366da75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c44e033eec33586ae8093a6366da75">&#9670;&#160;</a></span>hypotNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">HypotNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::hypotNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow using a concatenation of hypot() calls. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::hypotNorm() </dd></dl>

</div>
</div>
<a id="ade4f61d09bf8f83cad382dfb037aee9c" name="ade4f61d09bf8f83cad382dfb037aee9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4f61d09bf8f83cad382dfb037aee9c">&#9670;&#160;</a></span>lpNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;int p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const LpNormReturnType&lt; p &gt;::Type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::lpNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the norm of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().norm() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>DenseBase::norm() </dd></dl>

</div>
</div>
<a id="a6646b584db116c1661b5bb56750bd6f6" name="a6646b584db116c1661b5bb56750bd6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6646b584db116c1661b5bb56750bd6f6">&#9670;&#160;</a></span>maxCoeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MaxCoeffReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::maxCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the largest coefficient of each column (or row) of the referenced expression.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the size along the reduction direction must be strictly positive, otherwise an assertion is triggered.</dd>
<dd>
the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().maxCoeff() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a7e6987d106f1cca3ac6ab36d288cc8e1">DenseBase::maxCoeff()</a> </dd></dl>

</div>
</div>
<a id="aaf7d867f9e6b74a1bc7f108d646cfa85" name="aaf7d867f9e6b74a1bc7f108d646cfa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7d867f9e6b74a1bc7f108d646cfa85">&#9670;&#160;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MeanReturnType <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the mean of each column (or row) of the referenced expression.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a21ac6c0419a72ad7a88ea0bc189017d7">DenseBase::mean()</a> </dd></dl>

</div>
</div>
<a id="a7d7b8c03d180b126fde0ac212e2b0b76" name="a7d7b8c03d180b126fde0ac212e2b0b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7b8c03d180b126fde0ac212e2b0b76">&#9670;&#160;</a></span>minCoeff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MinCoeffReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::minCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the smallest coefficient of each column (or row) of the referenced expression.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the size along the reduction direction must be strictly positive, otherwise an assertion is triggered.</dd>
<dd>
the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the minimum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().minCoeff() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a0739f9c868c331031c7810e21838dcb2">DenseBase::minCoeff()</a> </dd></dl>

</div>
</div>
<a id="af726d1dfd9a7a67b76e639db1a9f352e" name="af726d1dfd9a7a67b76e639db1a9f352e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af726d1dfd9a7a67b76e639db1a9f352e">&#9670;&#160;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">NormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the norm of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().norm() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>DenseBase::norm() </dd></dl>

</div>
</div>
<a id="adb1084153780dc8d2c062fee97651a45" name="adb1084153780dc8d2c062fee97651a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1084153780dc8d2c062fee97651a45">&#9670;&#160;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalize in-place each row or columns of the referenced matrix. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ad16303c47ba36f7a41ea264cb26bceb6">MatrixBase::normalize()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a4fe5af25f4d5c01d4eb844b13665219a">normalized()</a> </dd></dl>

</div>
</div>
<a id="a4fe5af25f4d5c01d4eb844b13665219a" name="a4fe5af25f4d5c01d4eb844b13665219a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe5af25f4d5c01d4eb844b13665219a">&#9670;&#160;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename OppositeExtendedType&lt; <a class="el" href="classEigen_1_1CwiseUnaryOp.html">NormReturnType</a> &gt;::Type &gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::normalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression where each column (or row) of the referenced matrix are normalized. The referenced matrix is <b>not</b> modified. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a5cf2fd4c57e59604fd4116158fd34308">MatrixBase::normalized()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#adb1084153780dc8d2c062fee97651a45">normalize()</a> </dd></dl>

</div>
</div>
<a id="a03e68903d3f06c993824f9f4ab9b2dfb" name="a03e68903d3f06c993824f9f4ab9b2dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e68903d3f06c993824f9f4ab9b2dfb">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression where each subvector is the product of the vector <em>other</em> by the corresponding subvector of <code>*this</code> </p>

</div>
</div>
<a id="a754261f465f54897e7fdcb8b8e168193" name="a754261f465f54897e7fdcb8b8e168193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754261f465f54897e7fdcb8b8e168193">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType &amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies each subvector of <code>*this</code> by the vector <em>other</em> </p>

</div>
</div>
<a id="a3e8cdb3bf914538158ec5e2d3f098289" name="a3e8cdb3bf914538158ec5e2d3f098289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8cdb3bf914538158ec5e2d3f098289">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_sum_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression of the sum of the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="abed7f1387a37976c0fa96727d8988cc4" name="abed7f1387a37976c0fa96727d8988cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed7f1387a37976c0fa96727d8988cc4">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType &amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="a1b3322dbbc17aaf778ce8e71412cedc8" name="a1b3322dbbc17aaf778ce8e71412cedc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3322dbbc17aaf778ce8e71412cedc8">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_difference_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression of the difference between each subvector of <code>*this</code> and the vector <em>other</em> </p>

</div>
</div>
<a id="a3da734a56ad8885d59536990669d9251" name="a3da734a56ad8885d59536990669d9251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da734a56ad8885d59536990669d9251">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType &amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="a96238a50bff53f4e2d2004e8cc10ec51" name="a96238a50bff53f4e2d2004e8cc10ec51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96238a50bff53f4e2d2004e8cc10ec51">&#9670;&#160;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression where each subvector is the quotient of the corresponding subvector of <code>*this</code> by the vector <em>other</em> </p>

</div>
</div>
<a id="a508f9152d709faadc120d615e3c33b68" name="a508f9152d709faadc120d615e3c33b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508f9152d709faadc120d615e3c33b68">&#9670;&#160;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType &amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides each subvector of <code>*this</code> by the vector <em>other</em> </p>

</div>
</div>
<a id="ab89e67f222ca4059d9d1097c22cc7ff9" name="ab89e67f222ca4059d9d1097c22cc7ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89e67f222ca4059d9d1097c22cc7ff9">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType &amp; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="a01bcd17504f30b55b4910ddb75598f79" name="a01bcd17504f30b55b4910ddb75598f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bcd17504f30b55b4910ddb75598f79">&#9670;&#160;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">ProdReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::prod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the product of each column (or row) of the referenced expression.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the product of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().prod() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#af119d9a4efe5a15cd83c1ccdf01b3a4f">DenseBase::prod()</a> </dd></dl>

</div>
</div>
<a id="a91a8087eb76e210b07192c81d362dd1e" name="a91a8087eb76e210b07192c81d362dd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a8087eb76e210b07192c81d362dd1e">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a reverse iterator to the last row (rowwise) or column (colwise) of the nested expression. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#aa9592e93b704f7712e8f33631a2efe8f">rend()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#aec95725eed4adb5ccf65fbb6e907d12e">crbegin()</a> </dd></dl>

</div>
</div>
<a id="aa73e8a0230fcc049346057ef1a6efe02" name="aa73e8a0230fcc049346057ef1a6efe02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73e8a0230fcc049346057ef1a6efe02">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a91a8087eb76e210b07192c81d362dd1e">rbegin()</a> </p>

</div>
</div>
<a id="af92284ced994812cd5e7f4520c0445fb" name="af92284ced994812cd5e7f4520c0445fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92284ced994812cd5e7f4520c0445fb">&#9670;&#160;</a></span>redux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename BinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ReduxReturnType&lt; BinaryOp &gt;::Type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::redux </td>
          <td>(</td>
          <td class="paramtype">const BinaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>BinaryOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row or column vector expression of <code>*this</code> reduxed by <em>func</em> </dd></dl>
<p>The template parameter <em>BinaryOp</em> is the type of the functor of the custom redux operator. Note that func must be an associative operator.</p>
<dl class="section warning"><dt>Warning</dt><dd>the size along the reduction direction must be strictly positive, otherwise an assertion is triggered.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing broadcasting and partial reduction operations.">VectorwiseOp</a>, <a class="el" href="classEigen_1_1DenseBase.html#a58837c81de446efbdb58da07b73a63c1">DenseBase::colwise()</a>, <a class="el" href="classEigen_1_1DenseBase.html#aa1cabd3404528fe8cec4bab43d74bffc">DenseBase::rowwise()</a> </dd></dl>

</div>
</div>
<a id="aa9592e93b704f7712e8f33631a2efe8f" name="aa9592e93b704f7712e8f33631a2efe8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9592e93b704f7712e8f33631a2efe8f">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a reverse iterator to the row (resp. column) before the first row (resp. column) of the nested expression </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a57859b88a32b8b393a427c4cab3581a7">cend()</a> </dd></dl>

</div>
</div>
<a id="afeb3e3ceca37ae0a6e313f80743f767a" name="afeb3e3ceca37ae0a6e313f80743f767a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb3e3ceca37ae0a6e313f80743f767a">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>const version of <a class="el" href="classEigen_1_1VectorwiseOp.html#aa9592e93b704f7712e8f33631a2efe8f">rend()</a> </p>

</div>
</div>
<a id="a5f0c8dc9e9c4aeaa2057f15800f5c18c" name="a5f0c8dc9e9c4aeaa2057f15800f5c18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0c8dc9e9c4aeaa2057f15800f5c18c">&#9670;&#160;</a></span>replicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::ReplicateReturnType <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of each column (or row) of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Vector3i</a> v = Vector3i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;v.rowwise().replicate(5) = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; v.rowwise().replicate(5) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a5f0c8dc9e9c4aeaa2057f15800f5c18c">VectorwiseOp::replicate()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate()</a>, class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="a01aca6b0627570d35e3b3000acd10b88" name="a01aca6b0627570d35e3b3000acd10b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aca6b0627570d35e3b3000acd10b88">&#9670;&#160;</a></span>replicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<div class="memtemplate">
template&lt;int Factor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; ExpressionType, isVertical *Factor+isHorizontal, isHorizontal *Factor+isVertical &gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a>&#160;</td>
          <td class="paramname"><em>factor</em> = <code>Factor</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of each column (or row) of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">MatrixXi</a> m = MatrixXi::Random(2,3);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.colwise().replicate&lt;3&gt;() = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.colwise().replicate&lt;3&gt;() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>VectorwiseOp::replicate(Index), <a class="el" href="classEigen_1_1DenseBase.html#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate()</a>, class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="ab8caf5367e2bd636536c8a0e0c89fe15" name="ab8caf5367e2bd636536c8a0e0c89fe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8caf5367e2bd636536c8a0e0c89fe15">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable matrix expression where each column (or row) are reversed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#aeb0428f561b5757e2c85e8d72022eec1">reverse() const </a> </dd></dl>

</div>
</div>
<a id="aeb0428f561b5757e2c85e8d72022eec1" name="aeb0428f561b5757e2c85e8d72022eec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0428f561b5757e2c85e8d72022eec1">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a matrix expression where each column (or row) are reversed.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">MatrixXi</a> m = MatrixXi::Random(3,4);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the rowwise reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().reverse() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the colwise reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().reverse() &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the coefficient (1,0) in the rowise reverse of m:&quot;</span> &lt;&lt; endl</div>
<div class="line">&lt;&lt; m.rowwise().reverse()(1,0) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Let us overwrite this coefficient with the value 4.&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="comment">//m.colwise().reverse()(1,0) = 4;</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a38ea394036d8b096abf322469c80198f">DenseBase::reverse()</a> </dd></dl>

</div>
</div>
<a id="ab9dd7c273eb2ba8defaab2d55156936b" name="ab9dd7c273eb2ba8defaab2d55156936b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dd7c273eb2ba8defaab2d55156936b">&#9670;&#160;</a></span>reverseInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverseInPlace</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of <a class="el" href="classEigen_1_1VectorwiseOp.html#aeb0428f561b5757e2c85e8d72022eec1">VectorwiseOp::reverse</a>: it reverses each column or row of <code>*this</code>.</p>
<p>In most cases it is probably better to simply use the reversed expression of a matrix. However, when reversing the matrix data itself is really needed, then this "in-place" version is probably the right choice because it provides the following additional benefits:</p><ul>
<li>less error prone: doing the same operation with .<a class="el" href="classEigen_1_1VectorwiseOp.html#ab8caf5367e2bd636536c8a0e0c89fe15">reverse()</a> requires special care: <div class="fragment"><div class="line">m = m.reverse().eval(); </div>
</div><!-- fragment --></li>
<li>this API enables reverse operations without the need for a temporary</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#adb8045155ea45f7961fc2a5170e1d921">DenseBase::reverseInPlace()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#ab8caf5367e2bd636536c8a0e0c89fe15">reverse()</a> </dd></dl>

</div>
</div>
<a id="a01474cf971473a73c919f6a99323d4f5" name="a01474cf971473a73c919f6a99323d4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01474cf971473a73c919f6a99323d4f5">&#9670;&#160;</a></span>squaredNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SquaredNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::squaredNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the squared norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the square norm of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().squaredNorm() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd>DenseBase::squaredNorm() </dd></dl>

</div>
</div>
<a id="add48fd836be98ed280cac23518db0916" name="add48fd836be98ed280cac23518db0916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add48fd836be98ed280cac23518db0916">&#9670;&#160;</a></span>stableNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">StableNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::stableNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::stableNorm() </dd></dl>

</div>
</div>
<a id="a7030fc687c24d687ed7cd70733ba611c" name="a7030fc687c24d687ed7cd70733ba611c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7030fc687c24d687ed7cd70733ba611c">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SumReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the sum of each column (or row) of the referenced expression.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classEigen_1_1Matrix.html">Matrix3d</a> m = Matrix3d::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().sum() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment"></pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">DenseBase::sum()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a595c33d2a82427a1159568b0b8438554" name="a595c33d2a82427a1159568b0b8438554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595c33d2a82427a1159568b0b8438554">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">random_access_iterator_type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the const version of iterator (aka read-only) </p>

</div>
</div>
<a id="a9fb8aaf24528efcdac1782aacf99b8dd" name="a9fb8aaf24528efcdac1782aacf99b8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb8aaf24528efcdac1782aacf99b8dd">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">random_access_iterator_type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>STL-like <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">RandomAccessIterator</a> iterator type over the columns or rows as returned by the <a class="el" href="classEigen_1_1VectorwiseOp.html#abbf3325f535ac011ed61f14ed4330618">begin()</a> and <a class="el" href="classEigen_1_1VectorwiseOp.html#a9d189042b8322e40772d41c63b9d3bb5">end()</a> methods. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="VectorwiseOp_8h_source.html">VectorwiseOp.h</a></li>
<li><a class="el" href="Replicate_8h_source.html">Replicate.h</a></li>
<li><a class="el" href="Reverse_8h_source.html">Reverse.h</a></li>
<li><a class="el" href="Homogeneous_8h_source.html">Homogeneous.h</a></li>
<li><a class="el" href="OrthoMethods_8h_source.html">OrthoMethods.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a></li>
    <li class="footer">Generated on Tue Jul 11 2023 17:10:43 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
