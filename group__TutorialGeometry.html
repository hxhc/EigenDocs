<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Space transformations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.4.90 (git rev 21cd3fe20990a5ac1d683806f605110962aac3f1)</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__TutorialGeometry.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Space transformations<div class="ingroups"><a class="el" href="group__Geometry__chapter.html">Geometry</a></div></div></div>
</div><!--header-->
<div class="contents">
<p>In this page, we will introduce the many possibilities offered by the <a class="el" href="group__Geometry__Module.html">geometry module</a> to deal with 2D and 3D rotations and projective or affine transformations.</p>
<p><a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>'s Geometry module provides two different kinds of geometric transformations:</p><ul>
<li>Abstract transformations, such as rotations (represented by <a class="el" href="classEigen_1_1AngleAxis.html">angle and axis</a> or by a <a class="el" href="classEigen_1_1Quaternion.html">quaternion</a>), <a class="el" href="classEigen_1_1Translation.html">translations</a>, scalings. These transformations are NOT represented as matrices, but you can nevertheless mix them with matrices and vectors in expressions, and convert them to matrices if you wish.</li>
<li>Projective or affine transformation matrices: see the <a class="el" href="classEigen_1_1Transform.html" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> class. These are really matrices.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If you are working with OpenGL 4x4 matrices then Affine3f and Affine3d are what you want. Since <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> defaults to column-major storage, you can directly use the Transform::data() method to pass your transformation matrix to OpenGL.</dd></dl>
<p>You can construct a <a class="el" href="classEigen_1_1Transform.html" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> from an abstract transformation, like this: </p><div class="fragment"><div class="line">Transform t(AngleAxis(angle,axis));</div>
</div><!-- fragment --><p> or like this: </p><div class="fragment"><div class="line">Transform t;</div>
<div class="line">t = AngleAxis(angle,axis);</div>
</div><!-- fragment --><p> But note that unfortunately, because of how C++ works, you can <b>not</b> do this: </p><div class="fragment"><div class="line">Transform t = AngleAxis(angle,axis);</div>
</div><!-- fragment --><p> <span class="note"><b>Explanation:</b> In the C++ language, this would require <a class="el" href="classEigen_1_1Transform.html" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> to have a non-explicit conversion constructor from <a class="el" href="classEigen_1_1AngleAxis.html" title="Represents a 3D rotation as a rotation angle around an arbitrary 3D axis.">AngleAxis</a>, but we really don't want to allow implicit casting here. </span></p>
<h1><a class="anchor" id="TutorialGeoElementaryTransformations"></a>
Transformation types</h1>
<table class="manual">
<tr>
<th>Transformation type</th><th>Typical initialization code </th></tr>
<tr>
<td><a class="el" href="classEigen_1_1Rotation2D.html">2D rotation</a> from an angle</td><td><div class="fragment"><div class="line">Rotation2D&lt;float&gt; rot2(angle_in_radian);</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>3D rotation as an <a class="el" href="classEigen_1_1AngleAxis.html">angle + axis</a></td><td><div class="fragment"><div class="line">AngleAxis&lt;float&gt; aa(angle_in_radian, Vector3f(ax,ay,az));</div>
</div><!-- fragment --> <span class="note">The axis vector must be normalized.</span> </td></tr>
<tr>
<td>3D rotation as a <a class="el" href="classEigen_1_1Quaternion.html">quaternion</a></td><td><div class="fragment"><div class="line">Quaternion&lt;float&gt; q;  q = AngleAxis&lt;float&gt;(angle_in_radian, axis);</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>N-D Scaling</td><td><div class="fragment"><div class="line">Scaling(sx, sy)</div>
<div class="line">Scaling(sx, sy, sz)</div>
<div class="line">Scaling(s)</div>
<div class="line">Scaling(vecN)</div>
</div><!-- fragment --> </td></tr>
<tr>
<td>N-D <a class="el" href="classEigen_1_1Translation.html" title="Represents a translation transformation.">Translation</a></td><td><div class="fragment"><div class="line">Translation&lt;float,2&gt;(tx, ty)</div>
<div class="line">Translation&lt;float,3&gt;(tx, ty, tz)</div>
<div class="line">Translation&lt;float,N&gt;(s)</div>
<div class="line">Translation&lt;float,N&gt;(vecN)</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>N-D <a class="el" href="group__TutorialGeometry.html#TutorialGeoTransform">Affine transformation</a></td><td><div class="fragment"><div class="line">Transform&lt;float,N,Affine&gt; t = concatenation_of_any_transformations;</div>
<div class="line">Transform&lt;float,3,Affine&gt; t = Translation3f(p) * AngleAxisf(a,axis) * Scaling(s);</div>
</div><!-- fragment --> </td></tr>
<tr>
<td>N-D Linear transformations <br  />
<em class="note">(pure rotations, <br  />
 scaling, etc.)</em></td><td><div class="fragment"><div class="line">Matrix&lt;float,N&gt; t = concatenation_of_rotations_and_scalings;</div>
<div class="line">Matrix&lt;float,2&gt; t = Rotation2Df(a) * Scaling(s);</div>
<div class="line">Matrix&lt;float,3&gt; t = AngleAxisf(a,axis) * Scaling(s);</div>
</div><!-- fragment --> </td></tr>
</table>
<p><b>Notes on rotations</b><br  />
 To transform more than a single vector the preferred representations are rotation matrices, while for other usages <a class="el" href="classEigen_1_1Quaternion.html" title="The quaternion class used to represent 3D orientations and rotations.">Quaternion</a> is the representation of choice as they are compact, fast and stable. Finally <a class="el" href="classEigen_1_1Rotation2D.html" title="Represents a rotation/orientation in a 2 dimensional space.">Rotation2D</a> and <a class="el" href="classEigen_1_1AngleAxis.html" title="Represents a 3D rotation as a rotation angle around an arbitrary 3D axis.">AngleAxis</a> are mainly convenient types to create other rotation objects.</p>
<p><b>Notes on <a class="el" href="classEigen_1_1Translation.html" title="Represents a translation transformation.">Translation</a> and Scaling</b><br  />
 Like <a class="el" href="classEigen_1_1AngleAxis.html" title="Represents a 3D rotation as a rotation angle around an arbitrary 3D axis.">AngleAxis</a>, these classes were designed to simplify the creation/initialization of linear (<a class="el" href="classEigen_1_1Matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a>) and affine (<a class="el" href="classEigen_1_1Transform.html" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a>) transformations. Nevertheless, unlike <a class="el" href="classEigen_1_1AngleAxis.html" title="Represents a 3D rotation as a rotation angle around an arbitrary 3D axis.">AngleAxis</a> which is inefficient to use, these classes might still be interesting to write generic and efficient algorithms taking as input any kind of transformations.</p>
<p>Any of the above transformation types can be converted to any other types of the same nature, or to a more generic type. Here are some additional examples: </p><table class="manual">
<tr>
<td><div class="fragment"><div class="line">Rotation2Df r;  r  = Matrix2f(..);       <span class="comment">// assumes a pure rotation matrix</span></div>
<div class="line">AngleAxisf aa;  aa = Quaternionf(..);</div>
<div class="line">AngleAxisf aa;  aa = Matrix3f(..);       <span class="comment">// assumes a pure rotation matrix</span></div>
<div class="line">Matrix2f m;     m  = Rotation2Df(..);</div>
<div class="line">Matrix3f m;     m  = Quaternionf(..);       Matrix3f m;   m = Scaling(..);</div>
<div class="line">Affine3f m;     m  = AngleAxis3f(..);       Affine3f m;   m = Scaling(..);</div>
<div class="line">Affine3f m;     m  = Translation3f(..);     Affine3f m;   m = Matrix3f(..);</div>
</div><!-- fragment --> </td></tr>
</table>
<p><a href="#" class="top">top</a></p>
<h1><a class="anchor" id="TutorialGeoCommontransformationAPI"></a>
Common API across transformation types</h1>
<p>To some extent, <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>'s <a class="el" href="group__Geometry__Module.html">geometry module</a> allows you to write generic algorithms working on any kind of transformation representations: </p><table class="manual">
<tr>
<td>Concatenation of two transformations</td><td><div class="fragment"><div class="line">gen1 * gen2;</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>Apply the transformation to a vector</td><td><div class="fragment"><div class="line">vec2 = gen1 * vec1;</div>
</div><!-- fragment --> </td></tr>
<tr>
<td>Get the inverse of the transformation</td><td><div class="fragment"><div class="line">gen2 = gen1.inverse();</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>Spherical interpolation <br  />
 (<a class="el" href="classEigen_1_1Rotation2D.html" title="Represents a rotation/orientation in a 2 dimensional space.">Rotation2D</a> and <a class="el" href="classEigen_1_1Quaternion.html" title="The quaternion class used to represent 3D orientations and rotations.">Quaternion</a> only)</td><td><div class="fragment"><div class="line">rot3 = rot1.slerp(alpha,rot2);</div>
</div><!-- fragment --> </td></tr>
</table>
<p><a href="#" class="top">top</a></p>
<h1><a class="anchor" id="TutorialGeoTransform"></a>
Affine transformations</h1>
<p>Generic affine transformations are represented by the <a class="el" href="classEigen_1_1Transform.html" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> class which internally is a (Dim+1)^2 matrix. In <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> we have chosen to not distinghish between points and vectors such that all points are actually represented by displacement vectors from the origin ( \( \mathbf{p} \equiv \mathbf{p}-0 \) ). With that in mind, real points and vector distinguish when the transformation is applied. </p><table class="manual">
<tr>
<td>Apply the transformation to a <b>point</b> </td><td><div class="fragment"><div class="line">VectorNf p1, p2;</div>
<div class="line">p2 = t * p1;</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>Apply the transformation to a <b>vector</b> </td><td><div class="fragment"><div class="line">VectorNf vec1, vec2;</div>
<div class="line">vec2 = t.linear() * vec1;</div>
</div><!-- fragment --> </td></tr>
<tr>
<td>Apply a <em>general</em> transformation <br  />
 to a <b>normal</b> <b>vector</b> <br  />
</td><td><div class="fragment"><div class="line">VectorNf n1, n2;</div>
<div class="line">MatrixNf normalMatrix = t.linear().inverse().transpose();</div>
<div class="line">n2 = (normalMatrix * n1).normalized();</div>
</div><!-- fragment --> </td></tr>
<tr>
<td colspan="2">(See subject 5.27 of this <a href="http://www.faqs.org/faqs/graphics/algorithms-faq">faq</a> for the explanations) </td></tr>
<tr class="alt">
<td>Apply a transformation with <em>pure</em> <em>rotation</em> <br  />
 to a <b>normal</b> <b>vector</b> (no scaling, no shear)</td><td><div class="fragment"><div class="line">n2 = t.linear() * n1;</div>
</div><!-- fragment --> </td></tr>
<tr>
<td>OpenGL compatibility <b>3D</b> </td><td><div class="fragment"><div class="line">glLoadMatrixf(t.data());</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>OpenGL compatibility <b>2D</b> </td><td><div class="fragment"><div class="line">Affine3f aux(Affine3f::Identity());</div>
<div class="line">aux.linear().topLeftCorner&lt;2,2&gt;() = t.linear();</div>
<div class="line">aux.translation().start&lt;2&gt;() = t.translation();</div>
<div class="line">glLoadMatrixf(aux.data());</div>
</div><!-- fragment --> </td></tr>
</table>
<p><b>Component</b> <b>accessors</b> </p><table class="manual">
<tr>
<td>full read-write access to the internal matrix</td><td><div class="fragment"><div class="line">t.matrix() = matN1xN1;    <span class="comment">// N1 means N+1</span></div>
<div class="line">matN1xN1 = t.matrix();</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>coefficient accessors</td><td><div class="fragment"><div class="line">t(i,j) = scalar;   &lt;=&gt;   t.matrix()(i,j) = scalar;</div>
<div class="line">scalar = t(i,j);   &lt;=&gt;   scalar = t.matrix()(i,j);</div>
</div><!-- fragment --> </td></tr>
<tr>
<td>translation part</td><td><div class="fragment"><div class="line">t.translation() = vecN;</div>
<div class="line">vecN = t.translation();</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>linear part</td><td><div class="fragment"><div class="line">t.linear() = matNxN;</div>
<div class="line">matNxN = t.linear();</div>
</div><!-- fragment --> </td></tr>
<tr>
<td>extract the rotation matrix</td><td><div class="fragment"><div class="line">matNxN = t.rotation();</div>
</div><!-- fragment --> </td></tr>
</table>
<p><b>Transformation</b> <b>creation</b> <br  />
While transformation objects can be created and updated concatenating elementary transformations, the <a class="el" href="classEigen_1_1Transform.html" title="Represents an homogeneous transformation in a N dimensional space.">Transform</a> class also features a procedural API: </p><table class="manual">
<tr>
<th></th><th>procedural API</th><th>equivalent natural API  </th></tr>
<tr>
<td><a class="el" href="classEigen_1_1Translation.html" title="Represents a translation transformation.">Translation</a></td><td><div class="fragment"><div class="line">t.translate(Vector_(tx,ty,..));</div>
<div class="line">t.pretranslate(Vector_(tx,ty,..));</div>
</div><!-- fragment --></td><td><div class="fragment"><div class="line">t *= Translation_(tx,ty,..);</div>
<div class="line">t = Translation_(tx,ty,..) * t;</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td><b>Rotation</b> <br  />
 <em class="note">In 2D and for the procedural API, any_rotation can also <br  />
 be an angle in radian</em></td><td><div class="fragment"><div class="line">t.rotate(any_rotation);</div>
<div class="line">t.prerotate(any_rotation);</div>
</div><!-- fragment --></td><td><div class="fragment"><div class="line">t *= any_rotation;</div>
<div class="line">t = any_rotation * t;</div>
</div><!-- fragment --> </td></tr>
<tr>
<td>Scaling</td><td><div class="fragment"><div class="line">t.scale(Vector_(sx,sy,..));</div>
<div class="line">t.scale(s);</div>
<div class="line">t.prescale(Vector_(sx,sy,..));</div>
<div class="line">t.prescale(s);</div>
</div><!-- fragment --></td><td><div class="fragment"><div class="line">t *= Scaling(sx,sy,..);</div>
<div class="line">t *= Scaling(s);</div>
<div class="line">t = Scaling(sx,sy,..) * t;</div>
<div class="line">t = Scaling(s) * t;</div>
</div><!-- fragment --> </td></tr>
<tr class="alt">
<td>Shear transformation <br  />
 ( <b>2D</b> <b>only</b> ! )</td><td><div class="fragment"><div class="line">t.shear(sx,sy);</div>
<div class="line">t.preshear(sx,sy);</div>
</div><!-- fragment --></td><td></td></tr>
</table>
<p>Note that in both API, any many transformations can be concatenated in a single expression as shown in the two following equivalent examples: </p><table class="manual">
<tr>
<td><div class="fragment"><div class="line">t.pretranslate(..).rotate(..).translate(..).scale(..);</div>
</div><!-- fragment --> </td></tr>
<tr>
<td><div class="fragment"><div class="line">t = Translation_(..) * t * RotationType(..) * Translation_(..) * Scaling(..);</div>
</div><!-- fragment --> </td></tr>
</table>
<p><a href="#" class="top">top</a></p>
<h1><a class="anchor" id="TutorialGeoEulerAngles"></a>
Euler angles</h1>
<table class="manual">
<tr>
<td style="max-width:30em;">Euler angles might be convenient to create rotation objects. On the other hand, since there exist 24 different conventions, they are pretty confusing to use. This example shows how to create a rotation matrix according to the 2-1-2 convention.</td><td><div class="fragment"><div class="line">Matrix3f m;</div>
<div class="line">m = AngleAxisf(angle1, Vector3f::UnitZ())</div>
<div class="line">    * AngleAxisf(angle2, Vector3f::UnitY())</div>
<div class="line">    * AngleAxisf(angle3, Vector3f::UnitZ());</div>
</div><!-- fragment --> </td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jul 11 2023 17:10:41 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
